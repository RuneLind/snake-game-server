<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake AI Arena</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    color: #eee;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    overflow: hidden;
    height: 100vh;
  }
  #container { display: flex; height: 100vh; }
  #game-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  #canvas { background: #0a0a0a; }
  #sidebar {
    width: 320px;
    background: #141414;
    border-left: 2px solid #333;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #333;
    text-align: center;
  }
  #sidebar-header h1 {
    font-size: 20px;
    font-weight: 700;
    letter-spacing: 2px;
    color: #fff;
  }
  #game-info {
    padding: 8px 16px;
    font-size: 12px;
    color: #666;
    border-bottom: 1px solid #222;
    display: flex;
    justify-content: space-between;
  }
  #leaderboard { flex: 1; overflow-y: auto; padding: 8px; }
  .snake-row {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    margin-bottom: 4px;
    border-radius: 8px;
    background: #1a1a1a;
    transition: all 0.3s ease;
  }
  .snake-row.dead { opacity: 0.4; }
  .snake-color {
    width: 16px; height: 16px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
  }
  .snake-info { flex: 1; min-width: 0; }
  .snake-name {
    font-size: 14px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .snake-stats { font-size: 11px; color: #888; margin-top: 2px; }
  .snake-score {
    font-size: 18px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    margin-left: 8px;
  }
  .snake-status { margin-left: 8px; font-size: 14px; }
  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }
  #overlay-text {
    font-size: 64px;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 40px rgba(255,255,255,0.3);
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  #overlay-text.visible { opacity: 1; }
  #notifications {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 20;
  }
  .notification {
    background: rgba(0,0,0,0.8);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 8px 16px;
    margin-bottom: 8px;
    font-size: 14px;
    animation: fadeInOut 3s ease forwards;
  }
  @keyframes fadeInOut {
    0% { opacity: 0; transform: translateX(-20px); }
    10% { opacity: 1; transform: translateX(0); }
    80% { opacity: 1; }
    100% { opacity: 0; }
  }
</style>
</head>
<body>
<div id="container">
  <div id="game-area">
    <canvas id="canvas"></canvas>
    <div id="overlay"><div id="overlay-text"></div></div>
    <div id="notifications"></div>
  </div>
  <div id="sidebar">
    <div id="sidebar-header"><h1>SNAKE AI ARENA</h1></div>
    <div id="game-info">
      <span id="tick-info">Tick: 0</span>
      <span id="status-info">Waiting</span>
      <span id="spectator-info">0 watching</span>
    </div>
    <div id="leaderboard"></div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const leaderboard = document.getElementById('leaderboard');
const tickInfo = document.getElementById('tick-info');
const statusInfo = document.getElementById('status-info');
const spectatorInfo = document.getElementById('spectator-info');
const overlayText = document.getElementById('overlay-text');
const notifications = document.getElementById('notifications');

let currentState = null;
let prevState = null;
let lastTickTime = 0;
let scale = 1;
let centerX = 0;
let centerY = 0;

function resizeCanvas() {
  const area = document.getElementById('game-area');
  const size = Math.min(area.clientWidth - 16, area.clientHeight - 16);
  canvas.width = size;
  canvas.height = size;
  centerX = size / 2;
  centerY = size / 2;
  if (currentState) {
    scale = (size / 2 - 20) / currentState.arenaRadius;
  }
}

window.addEventListener('resize', resizeCanvas);

function toScreen(x, y) {
  return { x: centerX + x * scale, y: centerY + y * scale };
}

function render() {
  requestAnimationFrame(render);
  if (!currentState) return;

  const w = canvas.width;
  const h = canvas.height;

  // Interpolation factor
  const elapsed = performance.now() - lastTickTime;
  const tickMs = 50;
  const t = Math.min(1, elapsed / tickMs);

  // Clear
  ctx.clearRect(0, 0, w, h);

  // Dark background
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, w, h);

  // Arena circle
  const arenaScreen = scale * currentState.arenaRadius;
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.fill();

  // Subtle grid
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.025)';
  ctx.lineWidth = 1;
  const gridSize = 200 * scale;
  const gridRange = arenaScreen;
  ctx.save();
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.clip();
  for (let gx = -gridRange; gx <= gridRange; gx += gridSize) {
    ctx.beginPath();
    ctx.moveTo(centerX + gx, centerY - gridRange);
    ctx.lineTo(centerX + gx, centerY + gridRange);
    ctx.stroke();
  }
  for (let gy = -gridRange; gy <= gridRange; gy += gridSize) {
    ctx.beginPath();
    ctx.moveTo(centerX - gridRange, centerY + gy);
    ctx.lineTo(centerX + gridRange, centerY + gy);
    ctx.stroke();
  }
  ctx.restore();

  // Boundary glow
  ctx.strokeStyle = 'rgba(255, 50, 50, 0.25)';
  ctx.lineWidth = Math.max(2, 15 * scale);
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.stroke();

  // Food
  for (const f of currentState.food) {
    const fp = toScreen(f.x, f.y);
    const r = Math.max(2, (f.value > 1 ? 9 : 6) * scale);
    ctx.fillStyle = f.value > 1 ? '#ff6b6b' : '#ffd43b';
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;

  // Snakes
  for (const snake of currentState.snakes) {
    if (!snake.alive || !snake.segments || snake.segments.length === 0) continue;
    drawSnake(snake, t);
  }
}

function drawSnake(snake, t) {
  const segments = snake.segments;
  const segCount = segments.length;
  const baseRadius = 12 * scale;

  // Interpolate head position
  const dx = Math.cos(snake.angle) * snake.speed * t;
  const dy = Math.sin(snake.angle) * snake.speed * t;
  const headInterp = toScreen(segments[0].x + dx, segments[0].y + dy);

  // Draw body from tail to head (head on top)
  for (let i = segCount - 1; i >= 1; i--) {
    const seg = toScreen(segments[i].x, segments[i].y);
    const taper = 0.6 + 0.4 * (i / (segCount - 1));
    const r = Math.max(2, baseRadius * taper);

    ctx.fillStyle = snake.color;
    ctx.beginPath();
    ctx.arc(seg.x, seg.y, r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Head (brighter, full size)
  ctx.fillStyle = lightenColor(snake.color, 40);
  ctx.beginPath();
  ctx.arc(headInterp.x, headInterp.y, Math.max(3, baseRadius), 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  drawEyes(headInterp.x, headInterp.y, snake.angle, baseRadius);

  // Name label
  ctx.font = `bold ${Math.max(10, Math.round(12 * scale * 8))}px sans-serif`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.shadowColor = 'rgba(0,0,0,0.9)';
  ctx.shadowBlur = 4;
  ctx.fillText(snake.participantName, headInterp.x, headInterp.y - baseRadius - 6);
  ctx.shadowBlur = 0;
}

function drawEyes(sx, sy, angle, baseRadius) {
  const eyeOffset = baseRadius * 0.5;
  const eyeSize = Math.max(1.5, baseRadius * 0.3);
  const perpAngle = angle + Math.PI / 2;

  const fwdX = Math.cos(angle) * eyeOffset * 0.5;
  const fwdY = Math.sin(angle) * eyeOffset * 0.5;
  const perpX = Math.cos(perpAngle) * eyeOffset;
  const perpY = Math.sin(perpAngle) * eyeOffset;

  const e1x = sx + fwdX + perpX;
  const e1y = sy + fwdY + perpY;
  const e2x = sx + fwdX - perpX;
  const e2y = sy + fwdY - perpY;

  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(e1x, e1y, eyeSize, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(e2x, e2y, eyeSize, 0, Math.PI * 2); ctx.fill();

  const pupilSize = eyeSize * 0.5;
  const pupilFwd = eyeSize * 0.3;
  const px = Math.cos(angle) * pupilFwd;
  const py = Math.sin(angle) * pupilFwd;

  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.arc(e1x + px, e1y + py, pupilSize, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(e2x + px, e2y + py, pupilSize, 0, Math.PI * 2); ctx.fill();
}

function lightenColor(hex, amount) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.min(255, (num >> 16) + amount);
  const g = Math.min(255, ((num >> 8) & 0xff) + amount);
  const b = Math.min(255, (num & 0xff) + amount);
  return `rgb(${r},${g},${b})`;
}

function updateLeaderboard() {
  if (!currentState) return;
  const sorted = [...currentState.snakes].sort((a, b) => b.totalScore - a.totalScore);
  leaderboard.innerHTML = sorted.map(s => `
    <div class="snake-row ${s.alive ? '' : 'dead'}">
      <div class="snake-color" style="background: ${s.color}"></div>
      <div class="snake-info">
        <div class="snake-name">${escapeHtml(s.participantName)}</div>
        <div class="snake-stats">
          L:${s.length} K:${s.totalKills}
          ${!s.alive && s.deathReason ? ' \u2620 ' + formatDeathReason(s.deathReason) : ''}
        </div>
      </div>
      <div class="snake-score" style="color: ${s.color}">${s.totalScore}</div>
      <div class="snake-status">${s.alive ? '\u{1F7E2}' : '\u{1F480}'}</div>
    </div>
  `).join('');
}

function formatDeathReason(reason) {
  if (!reason) return '';
  if (reason === 'boundary') return 'hit boundary';
  if (reason === 'self') return 'hit self';
  if (reason.startsWith('snake:')) return 'killed by ' + reason.slice(6);
  if (reason.startsWith('headon:')) return 'head-on with ' + reason.slice(7);
  return reason;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function showOverlay(text, durationMs = 2000) {
  overlayText.textContent = text;
  overlayText.classList.add('visible');
  setTimeout(() => overlayText.classList.remove('visible'), durationMs);
}

function addNotification(text, color = '#fff') {
  const el = document.createElement('div');
  el.className = 'notification';
  el.style.borderLeftColor = color;
  el.style.borderLeftWidth = '3px';
  el.textContent = text;
  notifications.appendChild(el);
  setTimeout(() => el.remove(), 3000);
}

// Socket.io
const socket = io();

socket.on('game:tick', (state) => {
  const firstUpdate = !currentState;
  prevState = currentState;
  currentState = state;
  lastTickTime = performance.now();
  if (firstUpdate) resizeCanvas();

  tickInfo.textContent = `Tick: ${state.tick}`;
  statusInfo.textContent = state.status.charAt(0).toUpperCase() + state.status.slice(1);
  spectatorInfo.textContent = `${state.spectatorCount} watching`;
  updateLeaderboard();
});

socket.on('game:started', () => showOverlay('GO!', 1500));
socket.on('game:paused', () => showOverlay('PAUSED'));
socket.on('game:finished', (data) => showOverlay(`${data.winnerName || 'Nobody'} WINS!`, 5000));
socket.on('snake:registered', (data) => addNotification(`${data.name} joined!`, data.color));
socket.on('snake:died', (data) => addNotification(`${data.name} died: ${formatDeathReason(data.reason)}`, '#ff4444'));
socket.on('snake:respawned', (data) => addNotification(`${data.name} respawned`, '#44ff44'));
socket.on('connect', () => console.log('Connected to game server'));
socket.on('disconnect', () => showOverlay('DISCONNECTED', 10000));

requestAnimationFrame(render);
</script>
</body>
</html>
