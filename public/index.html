<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake AI Arena</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    color: #eee;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    overflow: hidden;
    height: 100vh;
  }
  #container { display: flex; height: 100vh; }
  #stats-panel {
    width: 280px;
    background: #141414;
    border-right: 2px solid #333;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #stats-header {
    padding: 16px;
    border-bottom: 1px solid #333;
    text-align: center;
    font-size: 11px;
    font-weight: 700;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  #stats-list { flex: 1; overflow-y: auto; padding: 8px; }
  .stats-entry {
    background: #1a1a1a;
    border-radius: 8px;
    margin-bottom: 4px;
    overflow: hidden;
  }
  .stats-summary {
    display: flex;
    align-items: center;
    padding: 8px 10px;
  }
  .stats-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 8px;
    flex-shrink: 0;
  }
  .stats-name {
    flex: 1;
    font-size: 13px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    min-width: 0;
  }
  .stats-version {
    font-size: 11px;
    font-weight: 700;
    color: #888;
    margin-left: 6px;
    flex-shrink: 0;
  }
  .stats-meta {
    font-size: 10px;
    color: #666;
    padding: 0 10px 6px 18px;
  }
  #game-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  #canvas { background: #0a0a0a; }
  #sidebar {
    width: 320px;
    background: #141414;
    border-left: 2px solid #333;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #333;
    text-align: center;
  }
  #sidebar-header h1 {
    font-size: 20px;
    font-weight: 700;
    letter-spacing: 2px;
    color: #fff;
  }
  #game-info {
    padding: 8px 16px;
    font-size: 12px;
    color: #666;
    border-bottom: 1px solid #222;
    display: flex;
    justify-content: space-between;
  }
  #leaderboard { flex: 1; overflow-y: auto; padding: 8px; }
  .snake-row {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    margin-bottom: 4px;
    border-radius: 8px;
    background: #1a1a1a;
    transition: all 0.3s ease;
  }
  .snake-row.dead { opacity: 0.4; }
  .snake-color {
    width: 16px; height: 16px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
  }
  .snake-info { flex: 1; min-width: 0; }
  .snake-name {
    font-size: 14px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .snake-stats { font-size: 11px; color: #888; margin-top: 2px; }
  .snake-score {
    font-size: 18px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    margin-left: 8px;
  }
  .snake-status { margin-left: 8px; font-size: 14px; }
  .snake-error {
    font-size: 10px;
    color: #e74c3c;
    margin-top: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 220px;
  }
  #admin-panel {
    padding: 12px;
    border-bottom: 1px solid #333;
  }
  #admin-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
  }
  .admin-btn {
    flex: 1;
    padding: 8px 0;
    border: none;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  .admin-btn:active { transform: scale(0.96); }
  .admin-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  #btn-start {
    background: #2ecc71;
    color: #000;
  }
  #btn-start:hover:not(:disabled) { background: #27ae60; }
  #btn-start.pause {
    background: #f39c12;
  }
  #btn-start.pause:hover:not(:disabled) { background: #d68910; }
  #btn-reset {
    background: #555;
    color: #fff;
  }
  #btn-reset:hover:not(:disabled) { background: #666; }
  #snake-count {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
  }
  #leaderboard-header {
    padding: 6px 12px;
    font-size: 11px;
    font-weight: 700;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }
  #overlay-text {
    font-size: 64px;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 40px rgba(255,255,255,0.3);
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  #overlay-text.visible { opacity: 1; }
  #notifications {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 20;
  }
  .notification {
    background: rgba(0,0,0,0.8);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 8px 16px;
    margin-bottom: 8px;
    font-size: 14px;
    animation: fadeInOut 3s ease forwards;
  }
  @keyframes fadeInOut {
    0% { opacity: 0; transform: translateX(-20px); }
    10% { opacity: 1; transform: translateX(0); }
    80% { opacity: 1; }
    100% { opacity: 0; }
  }
</style>
</head>
<body>
<div id="container">
  <div id="stats-panel">
    <div id="stats-header">Submissions</div>
    <div id="stats-list"></div>
  </div>
  <div id="game-area">
    <canvas id="canvas"></canvas>
    <div id="overlay"><div id="overlay-text"></div></div>
    <div id="notifications"></div>
  </div>
  <div id="sidebar">
    <div id="sidebar-header"><h1>SNAKE AI ARENA</h1></div>
    <div id="game-info">
      <span id="tick-info">Tick: 0</span>
      <span id="status-info">Waiting</span>
      <span id="spectator-info">0 watching</span>
    </div>
    <div id="admin-panel">
      <div id="admin-buttons">
        <button class="admin-btn" id="btn-start" onclick="toggleStartPause()">Start</button>
        <button class="admin-btn" id="btn-reset" onclick="doReset()">Reset</button>
      </div>
      <div id="snake-count">0 snakes registered</div>
    </div>
    <div id="leaderboard-header">Leaderboard</div>
    <div id="leaderboard"></div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const leaderboard = document.getElementById('leaderboard');
const tickInfo = document.getElementById('tick-info');
const statusInfo = document.getElementById('status-info');
const spectatorInfo = document.getElementById('spectator-info');
const overlayText = document.getElementById('overlay-text');
const notifications = document.getElementById('notifications');

let currentState = null;
let prevState = null;
let lastTickTime = 0;
let scale = 1;
let centerX = 0;
let centerY = 0;

function resizeCanvas() {
  const area = document.getElementById('game-area');
  const size = Math.min(area.clientWidth - 16, area.clientHeight - 16);
  canvas.width = size;
  canvas.height = size;
  centerX = size / 2;
  centerY = size / 2;
  if (currentState) {
    scale = (size / 2 - 20) / currentState.arenaRadius;
  }
}

window.addEventListener('resize', resizeCanvas);

function toScreen(x, y) {
  return { x: centerX + x * scale, y: centerY + y * scale };
}

function render() {
  requestAnimationFrame(render);
  if (!currentState) return;

  const w = canvas.width;
  const h = canvas.height;

  // Interpolation factor
  const elapsed = performance.now() - lastTickTime;
  const tickMs = 50;
  const t = Math.min(1, elapsed / tickMs);

  // Clear
  ctx.clearRect(0, 0, w, h);

  // Dark background
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, w, h);

  // Arena circle
  const arenaScreen = scale * currentState.arenaRadius;
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.fill();

  // Subtle grid
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.025)';
  ctx.lineWidth = 1;
  const gridSize = 200 * scale;
  const gridRange = arenaScreen;
  ctx.save();
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.clip();
  for (let gx = -gridRange; gx <= gridRange; gx += gridSize) {
    ctx.beginPath();
    ctx.moveTo(centerX + gx, centerY - gridRange);
    ctx.lineTo(centerX + gx, centerY + gridRange);
    ctx.stroke();
  }
  for (let gy = -gridRange; gy <= gridRange; gy += gridSize) {
    ctx.beginPath();
    ctx.moveTo(centerX - gridRange, centerY + gy);
    ctx.lineTo(centerX + gridRange, centerY + gy);
    ctx.stroke();
  }
  ctx.restore();

  // Boundary glow
  ctx.strokeStyle = 'rgba(255, 50, 50, 0.25)';
  ctx.lineWidth = Math.max(2, 15 * scale);
  ctx.beginPath();
  ctx.arc(centerX, centerY, arenaScreen, 0, Math.PI * 2);
  ctx.stroke();

  // Food
  for (const f of currentState.food) {
    const fp = toScreen(f.x, f.y);
    const r = Math.max(1.5, (f.value > 1 ? 6 : 3) * scale);
    ctx.fillStyle = f.value > 1 ? '#ff6b6b' : '#ffd43b';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;

  // Snakes
  for (const snake of currentState.snakes) {
    if (!snake.alive || !snake.segments || snake.segments.length === 0) continue;
    drawSnake(snake, t);
  }
}

function drawSnake(snake, t) {
  const segments = snake.segments;
  const segCount = segments.length;
  if (segCount < 2) return;
  const baseRadius = Math.max(3, 12 * scale);

  // Interpolate head position
  const dx = Math.cos(snake.angle) * snake.speed * t;
  const dy = Math.sin(snake.angle) * snake.speed * t;
  const headInterp = toScreen(segments[0].x + dx, segments[0].y + dy);

  // Build screen points: interpolated head + rest of body
  const pts = [headInterp];
  for (let i = 1; i < segCount; i++) {
    pts.push(toScreen(segments[i].x, segments[i].y));
  }

  // Draw body as a thick rounded stroke (tail to head)
  // Outer body (darker outline for depth)
  ctx.strokeStyle = darkenColor(snake.color, 40);
  ctx.lineWidth = baseRadius * 2 + 2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
  for (let i = pts.length - 2; i >= 0; i--) {
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.stroke();

  // Inner body (main color)
  ctx.strokeStyle = snake.color;
  ctx.lineWidth = baseRadius * 2 - 2;
  ctx.beginPath();
  ctx.moveTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
  for (let i = pts.length - 2; i >= 0; i--) {
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.stroke();

  // Head circle (brighter)
  ctx.fillStyle = lightenColor(snake.color, 50);
  ctx.beginPath();
  ctx.arc(headInterp.x, headInterp.y, baseRadius, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  drawEyes(headInterp.x, headInterp.y, snake.angle, baseRadius);

  // Name label
  const fontSize = Math.max(9, Math.min(14, Math.round(baseRadius * 1.2)));
  ctx.font = `bold ${fontSize}px sans-serif`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.shadowColor = 'rgba(0,0,0,0.9)';
  ctx.shadowBlur = 3;
  ctx.fillText(snake.participantName, headInterp.x, headInterp.y - baseRadius - 4);
  ctx.shadowBlur = 0;
}

function drawEyes(sx, sy, angle, baseRadius) {
  const eyeOffset = baseRadius * 0.5;
  const eyeSize = Math.max(1.5, baseRadius * 0.3);
  const perpAngle = angle + Math.PI / 2;

  const fwdX = Math.cos(angle) * eyeOffset * 0.5;
  const fwdY = Math.sin(angle) * eyeOffset * 0.5;
  const perpX = Math.cos(perpAngle) * eyeOffset;
  const perpY = Math.sin(perpAngle) * eyeOffset;

  const e1x = sx + fwdX + perpX;
  const e1y = sy + fwdY + perpY;
  const e2x = sx + fwdX - perpX;
  const e2y = sy + fwdY - perpY;

  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(e1x, e1y, eyeSize, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(e2x, e2y, eyeSize, 0, Math.PI * 2); ctx.fill();

  const pupilSize = eyeSize * 0.5;
  const pupilFwd = eyeSize * 0.3;
  const px = Math.cos(angle) * pupilFwd;
  const py = Math.sin(angle) * pupilFwd;

  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.arc(e1x + px, e1y + py, pupilSize, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(e2x + px, e2y + py, pupilSize, 0, Math.PI * 2); ctx.fill();
}

function lightenColor(hex, amount) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.min(255, (num >> 16) + amount);
  const g = Math.min(255, ((num >> 8) & 0xff) + amount);
  const b = Math.min(255, (num & 0xff) + amount);
  return `rgb(${r},${g},${b})`;
}

function darkenColor(hex, amount) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.max(0, (num >> 16) - amount);
  const g = Math.max(0, ((num >> 8) & 0xff) - amount);
  const b = Math.max(0, (num & 0xff) - amount);
  return `rgb(${r},${g},${b})`;
}

function updateLeaderboard() {
  if (!currentState) return;
  // Sort by best length (high score), then by current length as tiebreak
  const sorted = [...currentState.snakes].sort((a, b) => {
    const aScore = Math.max(a.bestLength, a.alive ? a.length : 0);
    const bScore = Math.max(b.bestLength, b.alive ? b.length : 0);
    if (bScore !== aScore) return bScore - aScore;
    return (b.alive ? b.length : 0) - (a.alive ? a.length : 0);
  });
  leaderboard.innerHTML = sorted.map(s => {
    const current = s.alive ? s.length : 0;
    const best = s.bestLength;
    const displayScore = Math.max(best, current);
    return `
    <div class="snake-row ${s.alive ? '' : 'dead'}">
      <div class="snake-color" style="background: ${s.color}"></div>
      <div class="snake-info">
        <div class="snake-name">${escapeHtml(s.participantName)}</div>
        <div class="snake-stats">
          ${s.alive ? `Now: ${current}` : 'Dead'}${best > 0 ? ` \u00b7 Best: ${best}` : ''}
          ${s.totalKills ? ` \u00b7 \u{1F52B}${s.totalKills}` : ''}${s.deaths ? ` \u00b7 \u{1F480}${s.deaths}` : ''}
          ${!s.alive && s.deathReason ? ' \u00b7 ' + formatDeathReason(s.deathReason) : ''}
        </div>
        ${s.lastAIError ? `<div class="snake-error">\u26a0 ${escapeHtml(s.lastAIError)}</div>` : ''}
      </div>
      <div class="snake-score" style="color: ${s.color}">${displayScore}</div>
      <div class="snake-status">${s.alive ? '\u{1F7E2}' : '\u{1F480}'}</div>
    </div>
  `}).join('');
}

const statsList = document.getElementById('stats-list');

function updateStatsPanel() {
  if (!currentState) return;
  const sorted = [...currentState.snakes].sort((a, b) => {
    return (b.submissionCount || 0) - (a.submissionCount || 0);
  });

  statsList.innerHTML = sorted.map(s => {
    const version = s.submissionCount || 0;
    const lines = s.latestLines || 0;
    return `
    <div class="stats-entry">
      <div class="stats-summary">
        <span class="stats-dot" style="background: ${s.color}"></span>
        <span class="stats-name">${escapeHtml(s.participantName)}</span>
        <span class="stats-version">v${version}</span>
      </div>
      <div class="stats-meta">${lines} lines \u00b7 \u{1F52B}${s.totalKills || 0} \u00b7 \u{1F480}${s.deaths || 0}</div>
    </div>`;
  }).join('');
}

function formatDeathReason(reason) {
  if (!reason) return '';
  if (reason === 'boundary') return 'hit boundary';
  if (reason === 'self') return 'hit self';
  if (reason.startsWith('snake:')) return 'killed by ' + reason.slice(6);
  if (reason.startsWith('headon:')) return 'head-on with ' + reason.slice(7);
  return reason;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function showOverlay(text, durationMs = 2000) {
  overlayText.textContent = text;
  overlayText.classList.add('visible');
  setTimeout(() => overlayText.classList.remove('visible'), durationMs);
}

function addNotification(text, color = '#fff') {
  const el = document.createElement('div');
  el.className = 'notification';
  el.style.borderLeftColor = color;
  el.style.borderLeftWidth = '3px';
  el.textContent = text;
  notifications.appendChild(el);
  setTimeout(() => el.remove(), 3000);
}

// Admin controls
const btnStart = document.getElementById('btn-start');
const snakeCount = document.getElementById('snake-count');

async function toggleStartPause() {
  if (!currentState) return;
  const endpoint = currentState.status === 'running' ? '/api/admin/pause' : '/api/admin/start';
  btnStart.disabled = true;
  try { await fetch(endpoint, { method: 'POST' }); } catch (e) { console.error(e); }
  btnStart.disabled = false;
}

async function doReset() {
  if (!confirm('Reset game? Scores will be cleared.')) return;
  document.getElementById('btn-reset').disabled = true;
  try { await fetch('/api/admin/reset', { method: 'POST' }); } catch (e) { console.error(e); }
  document.getElementById('btn-reset').disabled = false;
}

function updateAdminPanel() {
  if (!currentState) return;
  const isRunning = currentState.status === 'running';
  btnStart.textContent = isRunning ? 'Pause' : 'Start';
  btnStart.className = 'admin-btn' + (isRunning ? ' pause' : '');
  const total = currentState.snakes.length;
  const alive = currentState.snakes.filter(s => s.alive).length;
  snakeCount.textContent = `${total} snake${total !== 1 ? 's' : ''} registered, ${alive} alive`;
}

// Socket.io
const socket = io();

socket.on('game:tick', (state) => {
  const firstUpdate = !currentState;
  prevState = currentState;
  currentState = state;
  lastTickTime = performance.now();
  if (firstUpdate) resizeCanvas();

  tickInfo.textContent = `Tick: ${state.tick}`;
  statusInfo.textContent = state.status.charAt(0).toUpperCase() + state.status.slice(1);
  spectatorInfo.textContent = `${state.spectatorCount} watching`;
  updateAdminPanel();
  updateLeaderboard();
  updateStatsPanel();
});

socket.on('game:started', () => showOverlay('GO!', 1500));
socket.on('game:paused', () => showOverlay('PAUSED'));
socket.on('game:finished', (data) => showOverlay(`${data.winnerName || 'Nobody'} WINS!`, 5000));
socket.on('snake:registered', (data) => addNotification(`${data.name} joined!`, data.color));
socket.on('snake:died', (data) => addNotification(`${data.name} died: ${formatDeathReason(data.reason)}`, '#ff4444'));
socket.on('snake:respawned', (data) => addNotification(`${data.name} respawned`, '#44ff44'));
socket.on('connect', () => console.log('Connected to game server'));
socket.on('disconnect', () => showOverlay('DISCONNECTED', 10000));

document.addEventListener('keydown', (e) => {
  if (e.key === 'f' || e.key === 'F') {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      document.documentElement.requestFullscreen();
    }
  }
});

requestAnimationFrame(render);
</script>
</body>
</html>
